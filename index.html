<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Converter</title>
    <style>
        body {
            background-color: #1a1a1a; /* Dark background color */
            color: #d3d3d3; /* Light text color */
            font-family: 'Courier New', monospace; /* Low-contrast font */
            max-width: 600px; /* Limit width for better readability */
            margin: 20px auto;
        }

        h2 {
            color: #ff9900; /* Accent color */
        }

        label {
            margin-top: 10px;
            display: block;
        }

        input, button {
            margin-top: 5px;
            padding: 8px;
            border: none;
            background-color: #404040; /* Input background color */
            color: #d3d3d3; /* Input text color */
            cursor: pointer;
        }

        button {
            background-color: #ff9900; /* Accent color for the button */
            color: #1a1a1a; /* Button text color */
        }
    </style>
</head>
<body>
     <h2>Select Your Image</h2>

    <!-- File selector for PNGs -->
    <input type="file" id="pngSelector">

    <!-- Input box for character width -->
    <label for="charWidth">Char Width:</label>
    <input type="number" id="charWidth" value="8">

    <!-- Input box for character height -->
    <label for="charHeight">Char Height:</label>
    <input type="number" id="charHeight" value="16">

    <!-- Button to generate OTF -->
    <button onclick="generateOTF()">Generate OTF</button>

   <script src="opentype.js"></script>
   <script>
        function generateOTF() {
            // Get selected PNG file
            const pngSelector = document.getElementById('pngSelector');
            const selectedFile = pngSelector.files[0];

            if (selectedFile) {
                const charWidth = parseInt(document.getElementById('charWidth').value);
                const charHeight = parseInt(document.getElementById('charHeight').value);

                const img = new Image();
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');

                const notdefGlyph = new opentype.Glyph({
                    name: '.notdef',
                    advanceWidth: 160,
                    path: new opentype.Path()
                });

                
                var glyphs = [notdefGlyph];
                const factor = 10;

                img.onload = function () {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    context.drawImage(img, 0, 0, img.width, img.height);

                    // Iterate through pixels
                    for (let y = 0; y < img.height; y += charHeight) {
                        for (let x = 0; x < img.width; x += charWidth) {
                            const pixelData = context.getImageData(x, y, charWidth, charHeight).data;

                          // Chunk pixel data into groups of four (assuming RGBA format)
                          const glyphPath = new opentype.Path();
                          for (let i = 0; i < pixelData.length; i += 4) {
                              const rgba = pixelData.slice(i, i + 4);

                              // Check if the pixel is white (assuming white is [255, 255, 255, 255])
                              const isWhite = rgba.every(value => value === 255);

                              const xmod = x % charWidth;
                              const ymod = x % charHeight;
                              if (isWhite) {
                                glyphPath.moveTo(xmod * factor, (charHeight - ymod) * factor);
                                glyphPath.lineTo((xmod + 1) * factor, (charHeight - ymod) * factor);
                                glyphPath.lineTo((xmod + 1) * factor, ((charHeight - ymod) - 1) * factor);
                                glyphPath.lineTo(xmod * factor, ((charHeight - ymod) - 1) * factor);
                              }
                          }
                          glyphPath.closePath();
                          const index = Math.floor(Math.floor(x / charWidth) + (Math.floor(y / charHeight) * (img.width / charWidth)));
                          const customGlyph = new opentype.Glyph({
                            name: 'custom glyph' + index,
                            unicode: index + 20,
                            advanceWidth: 80, // Adjust as needed
                            path: glyphPath
                          });
                          glyphs.push(customGlyph);
                          
                        }
                    }
 
                const font = new opentype.Font({
                    familyName: 'hortau_noise',
                    styleName: 'Medium',
                    unitsPerEm: 100,
                    ascender: 160,
                    descender: 0,
                    glyphs: glyphs
                });
                
                font.download();

                };

                const reader = new FileReader();
                reader.onload = function (e) {
                    img.src = e.target.result;
                };

                reader.readAsDataURL(selectedFile);
            } else {
                alert('Please select an image file.');
            }
        }
    </script>

</body>
</html>
